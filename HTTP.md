- http状态码
``` 
100 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。
101 服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 　　只有在切换新的协议更有好处的时候才应该采取类似措施。
102 处理将被继续执行。
200 成功
301 永久重定向
302 临时重定向
304 服务端已经执行了请求，但文件未变化。可以从缓存中获取所请求的资源
当浏览器请求某一文件时，发现自己缓存的文件有Last-Modified，就会在httpRequest里面添加消息头If-Modified-Since 和If-Non-Match，服务器在收到reqeust时，和服务器本地文件对比，如果没有更新，则仅仅返回一个响应头Head（状态码304，而没有响应体），客户端在收到这个响应时，就会从本地缓存加载请求的资源。
400 服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。
401 当前请求需要身份验证。
403 不允许访问那个资源
500 服务器故障
504 请求超时

```
- 说一下https的工作原理，里面涉及到的加密算法都有哪些？
```   
HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。
1）使用HTTPS传输数据是安全的，因为数据都是被加密传输的；
2）使用HTTPS需要在服务器端配置密钥对；
3）使用HTTPS需要花钱找专业的权威机构进行CA证书的签发。

用户在浏览器里输入一个https网址，然后连接到server的443端口
采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)
nginx里配置证书的引用，自己之前配置过。
数字证书简称CA，它由权威机构给某网站颁发的一种认可凭证

中间人攻击：
SSL劫持攻击和SSL剥离攻击
3.1 SSL劫持攻击
SSL劫持攻击即SSL证书欺骗攻击，攻击者为了获得HTTPS传输的明文数据，需要先将自己接入到客户端和目标网站之间；在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥，这样，中间人就可以得到明文传输带Key1、Key2和Pre-Master-Key，从而窃取客户端和服务端的通信数据；

但是对于客户端来说，如果中间人伪造了证书，在校验证书过程中会提示证书错误，由用户选择继续操作还是返回，由于大多数用户的安全意识不强，会选择继续操作，此时，中间人就可以获取浏览器和服务器之间的通信数据

3.2  SSL剥离攻击
这种攻击方式也需要将攻击者设置为中间人，之后见HTTPS范文替换为HTTP返回给浏览器，而中间人和服务器之间仍然保持HTTPS服务器。由于HTTP是明文传输的，所以中间人可以获取客户端和服务器传输数据

```


- HTTP协议（超文本传输协议）
```
1.0 协议缺陷:
无法复用链接，完成即断开，重新慢启动和 TCP 3次握手
head of line blocking: 线头阻塞，导致请求之间互相影响

1.1 改进:

1.缓存处理
2.带宽优化及网络连接的使用 // HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
3.错误状态码 // 新增了24个错误状态码
4.Host头处理 // 指定对应的虚拟站点
5.长连接(默认 keep-alive)，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟

新增功能:
断点续传
身份认证
状态管理
cache 缓存

Cache-Control
Expires
Last-Modified
Etag

2.0 改进:

1.二进制数据帧和流 // 基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
2.多路复用 // 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求(也就是流)。通过这个技术，可以避免 HTTP1.1版本中的请求a文件时候，b文件只能等待的阻塞问题，极大的提高传输性能。
3.header压缩 // HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
4.服务端推送

```

- 请求头结构和响应头结构
```  
请求行、请求头、空行（它的作用是通过一个空行，告诉服务器请求头部到此为止）、请求数据


响应行、响应头、空行和响应体

```

- 讲解一下https对称加密和非对称加密
```
对称加密：
发送方和接收方需要持有同一把密钥，发送消息和接收消息均使用该密钥。相对于非对称加密，对称加密具有更高的加解密速度，但双方都需要事先知道密钥，密钥在传输过程中可能会被窃取，因此安全性没有非对称加密高。
非对称加密：
接收方在发送消息前需要事先生成公钥和私钥，然后将公钥发送给发送方。发送放收到公钥后，将待发送数据用公钥加密，发送给接收方。接收到收到数据后，用私钥解密。
在这个过程中，公钥负责加密，私钥负责解密，数据在传输过程中即使被截获，攻击者由于没有私钥，因此也无法破解。
非对称加密算法的加解密速度低于对称加密算法，但是安全性更高。

```


- 三次握手与四次挥手

``` 
三次握手
1）发送端首先发送一个带有SYN（synchronize）标志地数据包给接收方。

2）接收方接收后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了。

3）最后，发送方再回传一个带有ACK标志的数据包，代表我知道了，表示’握手‘结束。

四次挥手

1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

 2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

 3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

 4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手



```


- ETag是这个字符串是怎么生成的？

```  

客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。

Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用If-None-Match

Etag 主要为了解决 Last-Modified 无法解决的一些问题。


```

- OSI七层协议

```  
7-应用层、6-表示层、5-会话层、4-传输层、3-网络层、2-数据链路层、1-物理层

其中高层（即7、6、5、4层）定义了应用程序的功能，下面3层（即3、2、1层）主要面向通过网络的端到端，点到点的数据流。


HTTP协议对应于应用层，tcp、udp协议对应于传输层，IP协议对应于网络层


```