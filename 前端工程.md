- 什么是前端路由？前端路由的 实现原理
- git rebase vs git merge
```
git merge

记录下合并动作 很多时候这种合并动作是垃圾信息
不会修改原 commit ID
冲突只解决一次
分支看着不大整洁，但是能看出合并的先后顺序
记录了真实的 commit 情况，包括每个分支的详情


git rebase

改变当前分支 branch out 的位置
得到更简洁的项目历史
每个 commit 都需要解决冲突
修改所有 commit ID
```



- 常见的设计模式有哪些？

```
1、js工厂模式
2、js构造函数模式
3、js原型模式
4、构造函数+原型的js混合模式
5、构造函数+原型的动态原型模式
6、观察者模式
7、发布订阅模式


```

- nginx
- Docker
```
Docker 就是基于 Linux 容器的一种上层封装，提供了更为简单易用的 API 用于操作 Docker，属于一种 容器解决方案。
基本概念: 在 Docker 中，有三个核心的概念:

镜像 (Image):

从原理上说，镜像属于一种 root 文件系统，包含了一些系统文件和环境配置等，可以将其理解成一套 最小操作系统。为了让镜像轻量化和可移植，Docker 采用了 Union FS 的分层存储模式。将文件系统分成一层一层的结构，逐步从底层往上层构建，每层文件都可以进行继承和定制。这里从前端的角度来理解: 镜像就类似于代码中的 class，可以通过继承与上层封装进行复用。
从外层系统看来，一个镜像就是一个 Image 二进制文件，可以任意迁移，删除，添加；




容器 (Container):

镜像是一份静态文件系统，无法进行运行时操作，就如class，如果我们不进行实例化时，便无法进行操作和使用。因此 容器可以理解成镜像的实例，即 new 镜像()，这样我们便可以创建、修改、操作容器；一旦创建后，就可以简单理解成一个轻量级的操作系统，可以在内部进行各种操作，例如运行 node 应用，拉取 git 等；
基于镜像的分层结构，容器是 以镜像为基础底层，在上面封装了一层 容器的存储层；

存储空间的生命周期与容器一致；
该层存储层会随着容器的销毁而销毁；
尽量避免往容器层写入数据；


容器中的数据的持久化管理主要由两种方式:

数据卷 (Volume): 一种可以在多个容器间共享的特殊目录，其处于容器外层，并不会随着容器销毁而删除；
挂载主机目录: 直接将一个主机目录挂载到容器中进行写入；




仓库 (Repository):

为了便于镜像的使用，Docker 提供了类似于 git 的仓库机制，在仓库中包含着各种各样版本的镜像。官方服务是 Docker Hub；
可以快速地从仓库中拉取各种类型的镜像，也可以基于某些镜像进行自定义，甚至发布到仓库供社区使用；
```
- SSR服务端渲染
- 说说svg和canvas各自的优缺点？
- 对PWA有什么了解
- 常见的设计模式有哪些？
- 
- babel编译原理

```
babylon 将 ES6/ES7 代码解析成 AST
babel-traverse 对 AST 进行遍历转译，得到新的 AST
新 AST 通过 babel-generator 转换成 ES5

```