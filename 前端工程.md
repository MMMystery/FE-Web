- 什么是前端路由？前端路由的 实现原理


- git rebase vs git merge
```
git merge

记录下合并动作 很多时候这种合并动作是垃圾信息
不会修改原 commit ID
冲突只解决一次
分支看着不大整洁，但是能看出合并的先后顺序
记录了真实的 commit 情况，包括每个分支的详情


git rebase

改变当前分支 branch out 的位置
得到更简洁的项目历史
每个 commit 都需要解决冲突
修改所有 commit ID
```



- 常见的设计模式有哪些？

```
1、js工厂模式
2、js构造函数模式
3、js原型模式
4、构造函数+原型的js混合模式
5、构造函数+原型的动态原型模式
6、观察者模式
7、发布订阅模式

```

- nginx
```  

#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;
    server {
            listen       80;
            server_name  localhost;
    
            #charset koi8-r;
    
            #access_log  logs/host.access.log  main;
    
            location / {
                root   html;
                index  index.html index.htm;
            }
            }
     }

```

- Docker
```
Docker 就是基于 Linux 容器的一种上层封装，提供了更为简单易用的 API 用于操作 Docker，属于一种 容器解决方案。
基本概念: 在 Docker 中，有三个核心的概念:

镜像 (Image):

从原理上说，镜像属于一种 root 文件系统，包含了一些系统文件和环境配置等，可以将其理解成一套 最小操作系统。为了让镜像轻量化和可移植，Docker 采用了 Union FS 的分层存储模式。将文件系统分成一层一层的结构，逐步从底层往上层构建，每层文件都可以进行继承和定制。这里从前端的角度来理解: 镜像就类似于代码中的 class，可以通过继承与上层封装进行复用。
从外层系统看来，一个镜像就是一个 Image 二进制文件，可以任意迁移，删除，添加；




容器 (Container):

镜像是一份静态文件系统，无法进行运行时操作，就如class，如果我们不进行实例化时，便无法进行操作和使用。因此 容器可以理解成镜像的实例，即 new 镜像()，这样我们便可以创建、修改、操作容器；一旦创建后，就可以简单理解成一个轻量级的操作系统，可以在内部进行各种操作，例如运行 node 应用，拉取 git 等；
基于镜像的分层结构，容器是 以镜像为基础底层，在上面封装了一层 容器的存储层；

存储空间的生命周期与容器一致；
该层存储层会随着容器的销毁而销毁；
尽量避免往容器层写入数据；


容器中的数据的持久化管理主要由两种方式:

数据卷 (Volume): 一种可以在多个容器间共享的特殊目录，其处于容器外层，并不会随着容器销毁而删除；
挂载主机目录: 直接将一个主机目录挂载到容器中进行写入；


仓库 (Repository):

为了便于镜像的使用，Docker 提供了类似于 git 的仓库机制，在仓库中包含着各种各样版本的镜像。官方服务是 Docker Hub；
可以快速地从仓库中拉取各种类型的镜像，也可以基于某些镜像进行自定义，甚至发布到仓库供社区使用；
```
- SSR服务端渲染

```  
优势：
1.更加利于SEO
服务端渲染返回给客户端的是已经获取了异步数据并执行JavaScript脚本的最终HTML，网络爬中就可以抓取到完整页面的信息。

2.首屏渲染加快
首屏的渲染是node发送过来的html字符串，并不依赖于js文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。

缺点：
1.服务端压力较大
本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源；

2.开发条件受限
在服务端渲染中，只会执行到componentDidMount之前的生命周期钩子，因此项目引用的第三方的库也不可用其它生命周期钩子，这对引用库的选择产生了很大的限制；


最好的处理方案：Next.js
而 Next.js 做的是同构渲染。同一套代码既可以在服务器端渲染，也可以在客户端渲染。
当我们首次访问时，换言之当我们访问首屏页面时，Next.js 使用服务器端渲染，为我们返回已经渲染完成的最终 HTML 页面。这样就同时解决了首屏白屏问题以及 SEO 问题。此后当我们再进行交互时，则使用客户端渲染。HTML、CSS、JS 等资源都不需要再重新请求，只需要通过 ajax/websocket 等途径获取数据，在客户端完成渲染过程。

```
- 说说svg和canvas各自的优缺点？
```  

svg优点：
矢量图，不依赖于像素，无限放大后不会失真。
svg缺点：
dom形式，涉及到动画时候需要更新dom，性能较低。
canvas优点：
定制型更强，可以绘制绘制自己想要的东西。
非dom结构形式，用JavaScript进行绘制，涉及到动画性能较高。
canvas缺点：
事件分发由canvas处理，绘制的内容的事件需要自己做处理。
依赖于像素，无法高效保真，画布较大时候性能较低。
canvas渲染较大画布的时候性能会较低：因为canvas依赖于像素，在绘制过程中是一个一个像素去绘制的，当画布足够大，像素点也就会足够多，那么想能就会足够低。


SVG：
不依赖分辨率

支持事件处理器

最适合带有大型渲染区域的应用程序（比如谷歌地图）

复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）

不适合游戏应用

Canvas：
依赖分辨率

不支持事件处理器

弱的文本渲染能力

能够以 .png 或 .jpg 格式保存结果图像

最适合图像密集型的游戏，其中的许多对象会被频繁重绘


```

- 对PWA有什么了解

``` 
 PWA 全称Progressive Web Apps(渐进式Web应用程序)，旨在使用现有的web技术提供用户更优的使用体验。 其中最重要的是，在离线(offline)时应用程序能够继续运行功能。这是通过使用名为 Service Workers 的网络技术来实现的。
 
 可靠（Reliable） 即使在不稳定的网络环境下，也能瞬间加载并展现
 快速响应（Fast） 快速响应，并且有平滑的动画响应用户的操作
 粘性(Engaging) 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面
 
```


- babel编译原理

```
babylon 将 ES6/ES7 代码解析成 AST
babel-traverse 对 AST 进行遍历转译，得到新的 AST
新 AST 通过 babel-generator 转换成 ES5

```