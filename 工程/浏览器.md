- 同源策略（如何判断是否同源）
``` 
- 协议相同
- 域名相同
- 端口相同
```

- 跨域解决方案

```
disable-chrome-security打开浏览器。关闭了浏览器的安全限制。
JSONP 只支持 GET 请求，但是可以兼容老式浏览器
CORS 支持所有的 HTTP 请求，是跨域最主流的方案 ，服务器设置header ：Access-Control-Allow-Origin。
Node 中间件和 Nginx 反向代理都是利用了服务器对服务器没有同源策略限制
Websocket 也是一种跨域的解决方案
PostMessage 可以实现跨文档通信，更多地用于窗口通信，iframe之间可以用postMessage通信（还能读取其他窗口的localstorage）
document.domain, window.name, location.hash 逐渐淡出历史舞台，作为替代， PostMessage 是一种不错的方案



cors的简单请求和非简单请求
什么标签可以进行跨域
正向代理和反向代理
JSONP缺点
cors只是后端设置就可以了吗?
cors跨域问题, 第一次请求怎么知道服务器是否允许携带cookie
可以写一个postmessage实现跨域的函数吗？
什么标签不受同源策略的影响
```
- 表单可以跨域吗
``` 
原页面用 form 提交到另一个域名之后，原页面的脚本无法获取新页面中的内容，所以浏览器认为这是安全的。

因为浏览器安全策略限制的是脚本，而并不限制src，form提交之类的请求。form表单提交不存在跨域
另外ajax是提交了的（调试工具中很容易看到请求已经发出），只是脚本无法获得结果。

```
- cors什么时候发一个请求，什么时候发两个？具体点？
- 常见的浏览器内核有哪些?

```
Trident（IE浏览器）
Gecko（Firefox浏览器）
Webkit（safari和Chrome浏览器）
介绍一下你对浏览器内核的理解？
主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。
渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。

```
- 浏览器的主要组成部分是什么？
``` 
用户界面（User Interface）
浏览器引擎（Browser Engine）
渲染引擎（Rendering Engine）
网络（Networking）
UI 后端－用来绘制类似组合选择框及对话框等基本组件
JavaScript解释器（JavaScript Interpreter）
数据存储
```
- 浏览器是如何渲染UI的？

``` 
浏览器将获取的HTML文档解析成DOM树。
处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)。
将DOM和CSSOM合并为渲染树(rendering tree)将会被创建，代表一系列将被渲染的对象。
渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素。
调用 GPU 将渲染树的各个节点绘制到屏幕上，这一步被称为绘制painting。

- cssom生成规则
在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠
```
- 浏览器如何解析html的

- 检测浏览器版本版本有哪些方式？以及怎么识别是在pc端还是在移动端

``` 
功能检测（window.navigation.userAgent）、请求头里的userAgent特征检测
window.Navigertion.useragent
或者请求头里面的：user-agent信息

```


- window.onload和document.ready
```
ready 事件的触发，表示文档结构已经加载完成（不包含图片等非文字媒体文件）。
onload 事件的触发，表示页面包含图片等文件在内的所有元素都加载完成。

页面加载完成有两种事件，一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是onload，指示页 面包含图片等文件在内的所有元素都加载完成。(可以说：ready 在onload 前加载！！！)我的理解： 一般样式控制的，比如图片大小控制放在onload 里面加载;              而：jS事件触发的方法，可以在ready 里面加载;

 onload
 必须等待网页全部加载完毕（包括图片等），然后再执行JS代码
 只能执行一次，如果第二次，那么第一次的执行会被覆盖
 
 ready
 只需要等待网页中的DOM结构加载完毕
 可以执行多次，N次都不会被覆盖

```

- 浏览器如何解析css选择器？

``` 
浏览器解析css选择器的规则是从右向左的，这样会提高查找选择器所对应的元素的效率
```
- DOM Tree是如何构建的？

- 图片的预加载和懒加载
```
预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染
懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数


两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。预加载则会增加服务器前端压力，懒加载对服务器有一定的缓解压力作用。

```

- 跨标签页的通讯方式有哪些
```
(1) BroadCast Channel
(2) Service Worker
(3) LocalStorage + window.onstorage监听
    重复写入相同的值无法触发
    会受到浏览器隐身模式等的限制

(4) Shared Worker + 定时器轮询(setInterval)
(5) IndexedDB + 定时器轮询(setInterval)
(6) cookie + 定时器轮询(setInterval)
(7) window.open + window.postMessage
(8) Websocket
(9) URL携带参数
```

- 输入URL到页面呈现发生了什么？
``` 
1.构建一个请求
2.查找强缓存
3.DNS解析（通过域名服务器找出对应ip）
4.建立Tcp连接（3次握手4次挥手）
5.发送HTTP请求
6.服务端接收请求，查询数据库，响应请求。
7.浏览器接收响应数据，通过渲染引擎和js引擎渲染页面

```
- tcp 包有什么内容 ？
- 浏览器和http缓存机制

```


强缓存(不需要发送http)

expires: Sat, 10 Mar 2029 04:01:39 GMT(绝对时间)
cache-control: max-age=315360000（有效期时间，优先级比expires高）
   

http1.0时期使用的是Expires
Expires即过期时期，存在于响应头中，告诉浏览器这个过期时间内可以直接从缓存里获取数据，无需请求。
潜在问题：服务器时间和客户端时间可能不一致，那就不准确，所以后面被抛弃了。

http1.1时期使用的是Cache-control
不像Expires采用具体过期时间，Cache-control是采用过期时长来控制缓存的，对应字段Cache-control： max-age=3600 // 代表响应后3600s内可以直接使用缓存
还有private，no-cathe，no-store，s-maxage等参数。

Cache-control的no-cache和no-store的区别？


对比：
Expires和Cache-control同时存在的时候，Cache-control会优先考虑。



协商缓存（需要发送http）

在强缓存不满足的情况下，开始协商缓存，请求头会携带tag向服务器发送请求，服务端根据tag来判断是否使用缓存，如果使用返回304.
last-modified: Tue, 12 Mar 2019 06:22:34 GMT（最近一次修改文件的绝对时间）
etag: "52-583dfb6f4de80"

1. Last-Modified/If-Modified-Since
Last-Modified表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，会和服务器中该资源最后修改时间最对比，如果小于最后修改时间，则更新，否则返回304，告诉浏览器使用缓存。

2. Etag/If-None-Match
Etag是服务器给当前文件生产的唯一标识，存在于响应头中，文件里面的内容只要有改动，这个值就会更新。
浏览器接收到Etag值，会在下次请求时候，将这个值作为If-None-Match字段的内容发送给服务端，服务端进行比较，如果不一致，则说明要发生了更新。

对比：

精度上Etag优于Last-Modified，因为Etag是按照内容来生成标识的，内容变化了就会更新。而Last-modified编辑了文件，内容不变，会造成缓存失败。
Last-Modified感知的时间单位是秒，如果一秒内更新多次，此时Last-Modified就不能体现出修改了。

性能上Last-Modified优于Etag，因为Last-Modified只需要记录时间点，而Etag要根据内容区生成哈希值。

两者都存在的话，Etag会优先考虑。


缓存在什么位置呢？

1.Service Worker  PWA实现机制，能实现离线缓存,可以借这个来做缓存文件，提高首屏渲染速度。
2.Memory Cache  内存上
3.Disk Cache  硬盘上
4.Push Cache  http2.0上的机制

Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。
对于大文件来说，大概率是不存储在内存中的，反之优先
当前系统内存使用率高的话，文件优先存储进硬盘

Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。


常用缓存策略：
对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存
对于频繁变动的资源，可以使用 Cache-Control: no-cache并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件


更新nginx的静态文件缓存策略（更新强缓存）
静态资源html不使用缓存，每次加载均从服务器中拉取最新的html文件

备注：CDN上也有缓存


```
- 如何实现强缓存，但是在资源变化后又主动获取新的资源
- localstorage
``` 
localstorage a.com和b.com能共享吗a.baidu.com和b.baidu.com呢 
答案：不行，同一域名才可以。同一个子域名都不行。
```
- 怎么在localstorage当中实现定时存储，过期清除，并且localstorage有大小限制，我怎么来清楚过期的内容
- sessionStorage

``` 
正确答案：刷新当前页面，或者通过location.href、window.open、或者通过带target="_blank"的a标签打开新标签，之前的sessionStorage还在，但是如果你是主动打开一个新窗口或者新标签，对不起，打开F12你会发现，sessionStorage空空如也。

也就是说，sessionStorage的session仅限当前标签页或者当前标签页打开的新标签页，通过其它方式新开的窗口或标签不认为是同一个session。

```

- 1px问题、如何适配

```  
使用viewport

在像素比为2的设备上设置scale = 1/devicePixelRatio也就是（1/2） = 0.5,变量scale设置为0.5就行。
在像素比为3的设备上设置scale = 1/devicePixelRatio也就是 (1/3) =0.333,变量scale设置为0.3333就行

```
- 浏览器渲染的主要流程是什么?

```
将html代码按照深度优先遍历来生成DOM树。
css文件下载完后也会进行渲染，生成相应的CSSOM。
当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。
接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。
最后，通过Painting环节将所有的节点内容呈现到屏幕上。

处理HTML标签建立DOM树
处理CSS标签建立CSSOM树
连接CSSOM树和DOM树形成一个render树
在render树上运行布局来计算每个节点的形状
在屏幕上画每一个节点

注意：
dom树加载和cssom树加载会阻塞render树的解析。


无论是外链CSS还是内联CSS都会阻塞DOM渲染（Rendering），然而DOM解析（Parsing）会正常进行。

JavaScript 只会阻塞后续的 DOM，前面的 DOM 在解析完成后会被立即渲染给用户。这也是为什么我们把脚本放在页面底部：脚本仍在下载时页面已经可以正常地显示了。

```

- 原型继承和经典继承有什么区别？
``` 
在原型继承中，对象实例直接从其他对象继承。通常使用工厂模式或 Object.create() 来创建对象实例。

在经典继承中，对象实例从类中继承他们的属性和函数。通常使用构造函数和 new 关键字来创建对象实例。

```
- V8垃圾回收机制

``` 
V8将内存分为了新生代空间和老生代空间
新生代空间：用于存活时间较短的对象。在64位操作系统有32MB的空间，32位操作系统有16MB空间。
老生代空间：用于存货事件较长的对象。在64位操作系统有1400MB空间，在32位操作系统有700MB空间。

```
- web worker
``` 
其实就是运行在后台的js，不会影响当前页面的性能。类似开启一个服务。
web worker允许 JavaScript 创建多个线程，但子线程完全受主线程控制，且不能操作 DOM。因此他还是保持了单线程的特性。

// 创建 worker
const worker = new Worker('work.js');

// 向主进程推送消息
worker.postMessage('Hello World');

// 监听主进程来的消息
worker.onmessage = function (event) {
  console.log('Received message ' + event.data);
}

限制:

同源限制
无法使用 document / window / alert / confirm
无法加载本地资源

```

- Geolocation定位

```
调动方法是window.navigator.geolocation.getCurrentPosition(handleSuccess, handleError, options);
```

- 为什么很多网站的静态资源url都是ui_1421321e6.css(文件名_hash.扩展名)而不是ui.css?14324e6（文件名.扩展名？hash）
``` 
第一种是重新生成了新的资源文件，旧的依旧存在。
第二种是改了资源文件，设定了新的版本。
```



- 首页白屏优化
``` 



懒执行

懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒
懒加载

懒加载就是将不关键的资源延后加载
懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载

懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等

```
- 计算首屏加载时间
``` 
window.performance 
```
- 前端存储
- web离线存储

- 单点登录

- service worker和 web worker？
``` 

Web Workers 是 现代浏览器 提供的一个javascript多线程解决方案，我们可以将一些大计算量的代码交由web Worker运行。
// 创建 worker
const myWorker = new Worker('worker.js');

// 向 worker 传递信息
myWorker.postMessage('Hello!');

// 接收从 worker 传递过来的信息
myWorker.onmessage = function(e) {
  console.log(e.data);
}


Service Worker是基于Web Worker的事件驱动的，他们执行的机制都是新开一个线程去处理一些额外的，以前不能直接处理的任务。对于Web Worker，我们可以使用它来进行复杂的计算，因为它并不阻塞浏览器主线程的渲染。而Service Worker，我们可以用它来进行本地缓存或请求转发，相当于一个浏览器端本地的proxy。

```

- 浏览器解析数据是等全部收到才解析，还是边收边解析？


- 如何做到修改url参数，页面不刷新
- 内存管理（讲了V8的内存管理机制，新生代老生代的算法
- 正常情况下，如果浏览器已经登录了百度账号，再另外打开一个tab页是会自动保持登录状态的，问怎样杜绝这个事情，使得每一次打开都是重新登录，给出实现方案。
- 零点自动刷新
- CI/CD整体流程
