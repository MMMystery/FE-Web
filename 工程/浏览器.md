- 同源策略（如何判断是否同源）
``` 
- 协议相同
- 域名相同
- 端口相同
```

- 跨域解决方案

```
disable-chrome-security打开浏览器。关闭了浏览器的安全限制。
JSONP 只支持 GET 请求，但是可以兼容老式浏览器
CORS 支持所有的 HTTP 请求，是跨域最主流的方案 ，服务器设置header ：Access-Control-Allow-Origin。
Node 中间件和 Nginx 反向代理都是利用了服务器对服务器没有同源策略限制
Websocket 也是一种跨域的解决方案
PostMessage 可以实现跨文档通信，更多地用于窗口通信，iframe之间可以用postMessage通信（还能读取其他窗口的localstorage）
document.domain, window.name, location.hash 逐渐淡出历史舞台，作为替代， PostMessage 是一种不错的方案



cors的简单请求和非简单请求
什么标签可以进行跨域
正向代理和反向代理
JSONP缺点
cors只是后端设置就可以了吗?
cors跨域问题, 第一次请求怎么知道服务器是否允许携带cookie
可以写一个postmessage实现跨域的函数吗？
什么标签不受同源策略的影响
```
- 表单可以跨域吗
``` 
原页面用 form 提交到另一个域名之后，原页面的脚本无法获取新页面中的内容，所以浏览器认为这是安全的。

因为浏览器安全策略限制的是脚本，而并不限制src，form提交之类的请求。form表单提交不存在跨域
另外ajax是提交了的（调试工具中很容易看到请求已经发出），只是脚本无法获得结果。

```
- cors什么时候发一个请求，什么时候发两个？具体点？
- 常见的浏览器内核有哪些?

```
Trident（IE浏览器）
Gecko（Firefox浏览器）
Webkit（safari和Chrome浏览器）
介绍一下你对浏览器内核的理解？
主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。
渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。

```
- 浏览器的主要组成部分是什么？
``` 
用户界面（User Interface）
浏览器引擎（Browser Engine）
渲染引擎（Rendering Engine）
网络（Networking）
UI 后端－用来绘制类似组合选择框及对话框等基本组件
JavaScript解释器（JavaScript Interpreter）
数据存储
```
- 浏览器是如何渲染UI的？

``` 
浏览器将获取的HTML文档解析成DOM树。
处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)。
将DOM和CSSOM合并为渲染树(rendering tree)将会被创建，代表一系列将被渲染的对象。
渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素。
将渲染树的各个节点绘制到屏幕上，这一步被称为绘制painting。

- cssom生成规则

```
- 浏览器如何解析html的

- 检测浏览器版本版本有哪些方式？以及怎么识别是在pc端还是在移动端

``` 
功能检测（window.navigation.userAgent）、请求头里的userAgent特征检测
window.Navigertion.useragent
或者请求头里面的：user-agent信息

```


- window.onload和document.ready
```
ready 事件的触发，表示文档结构已经加载完成（不包含图片等非文字媒体文件）。
onload 事件的触发，表示页面包含图片等文件在内的所有元素都加载完成。
```

- 浏览器如何解析css选择器？

``` 
浏览器解析css选择器的规则是从右向左的，这样会提高查找选择器所对应的元素的效率
```
- DOM Tree是如何构建的？

- 图片的预加载和懒加载
```
预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染
懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数


两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。预加载则会增加服务器前端压力，懒加载对服务器有一定的缓解压力作用。

```

- 跨标签页的通讯方式有哪些
```
(1) BroadCast Channel
(2) Service Worker
(3) LocalStorage + window.onstorage监听
(4) Shared Worker + 定时器轮询(setInterval)
(5) IndexedDB + 定时器轮询(setInterval)
(6) cookie + 定时器轮询(setInterval)
(7) window.open + window.postMessage
(8) Websocket
```

- 输入URL到页面呈现发生了什么？
``` 
1.构建一个请求
2.查找强缓存
3.DNS解析（通过域名服务器找出对应ip）
4.建立Tcp连接（3次握手4次挥手）
5.发送HTTP请求
6.服务端接收请求，查询数据库，响应请求。
7.浏览器接收响应数据，通过渲染引擎和js引擎渲染页面

```
- tcp 包有什么内容 ？
- 浏览器和http缓存机制

```


强缓存(不需要发送http)

http1.0时期使用的是Expires
Expires即过期时期，存在于响应头中，告诉浏览器这个过期时间内可以直接从缓存里获取数据，无需请求。
潜在问题：服务器时间和客户端时间可能不一致，那就不准确，所以后面被抛弃了。

http1.1时期使用的是Cache-control
不像Expires采用具体过期时间，Cache-control是采用过期时长来控制缓存的，对应字段Cache-control： max-age=3600 // 代表响应后3600s内可以直接使用缓存
还有private，no-cathe，no-store，s-maxage等参数。

Cache-control的no-cache和no-store的区别？


对比：
Expires和Cache-control同时存在的时候，Cache-control会优先考虑。



协商缓存（需要发送http）

在强缓存不满足的情况下，开始协商缓存，请求头会携带tag向服务器发送请求，服务端根据tag来判断是否使用缓存，如果使用返回304.


1. Last-Modified/If-Modified-Since
请求头会携带If-Modified-Since字段，会和服务器中该资源最后修改时间最对比，如果小于最后修改时间，则更新，否则返回304，告诉浏览器使用缓存。

2. Etag/If-None-Match
Etag是服务器给当前文件生产的唯一标识，存在于响应头中，文件里面的内容只要有改动，这个值就会更新。
浏览器接收到Etag值，会在下次请求时候，将这个值作为If-None-Match字段的内容发送给服务端，服务端进行比较，如果不一致，则说明要发生了更新。

对比：

精度上Etag优于Last-Modified，因为Etag是按照内容来生成标识的，内容变化了就会更新。而Last-modified编辑了文件，内容不变，会造成缓存失败。
Last-Modified感知的时间单位是秒，如果一秒内更新多次，此时Last-Modified就不能体现出修改了。

性能上Last-Modified优于Etag，因为Last-Modified只需要记录时间点，而Etag要根据内容区生成哈希值。

两者都存在的话，Etag会优先考虑。


缓存在什么位置呢？

1.Service Worker  PWA实现机制，能实现离线缓存
2.Memory Cache  内存上
3.Disk Cache  硬盘上
4.Push Cache  http2.0上的机制

Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。
对于大文件来说，大概率是不存储在内存中的，反之优先
当前系统内存使用率高的话，文件优先存储进硬盘

Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。


更新nginx的静态文件缓存策略（更新强缓存）
静态资源html不使用缓存，每次加载均从服务器中拉取最新的html文件

备注：CDN上也有缓存


```
- 如何实现强缓存，但是在资源变化后又主动获取新的资源
- localstorage
``` 
localstorage a.com和b.com能共享吗a.baidu.com和b.baidu.com呢
```
- 怎么在localstorage当中实现定时存储，过期清除，并且localstorage有大小限制，我怎么来清楚过期的内容
- sessionStorage

``` 
正确答案：刷新当前页面，或者通过location.href、window.open、或者通过带target="_blank"的a标签打开新标签，之前的sessionStorage还在，但是如果你是主动打开一个新窗口或者新标签，对不起，打开F12你会发现，sessionStorage空空如也。

也就是说，sessionStorage的session仅限当前标签页或者当前标签页打开的新标签页，通过其它方式新开的窗口或标签不认为是同一个session。

```

- 1px问题、如何适配

```  
使用viewport

在像素比为2的设备上设置scale = 1/devicePixelRatio也就是（1/2） = 0.5,变量scale设置为0.5就行。
在像素比为3的设备上设置scale = 1/devicePixelRatio也就是 (1/3) =0.333,变量scale设置为0.3333就行

```
- 浏览器渲染的主要流程是什么?

```
将html代码按照深度优先遍历来生成DOM树。
css文件下载完后也会进行渲染，生成相应的CSSOM。
当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。
接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。
最后，通过Painting环节将所有的节点内容呈现到屏幕上。

处理HTML标签建立DOM树
处理CSS标签建立CSSOM树
连接CSSOM树和DOM树形成一个render树
在render树上运行布局来计算每个节点的形状
在屏幕上画每一个节点

注意：
dom树加载和cssom树加载会阻塞render树的解析。

```


- V8垃圾回收机制

``` 
V8将内存分为了新生代空间和老生代空间
新生代空间：用于存活时间较短的对象。在64位操作系统有32MB的空间，32位操作系统有16MB空间。
老生代空间：用于存货事件较长的对象。在64位操作系统有1400MB空间，在32位操作系统有700MB空间。

```
- web worker
``` 
其实就是运行在后台的js，不会影响当前页面的性能。类似开启一个服务。w=new Worker("demo_workers.js");

```

- Geolocation定位

```
调动方法是window.navigator.geolocation.getCurrentPosition(handleSuccess, handleError, options);
```

- 为什么很多网站的静态资源url都是ui_1421321e6.css(文件名_hash.扩展名)而不是ui.css?14324e6（文件名.扩展名？hash）
``` 
第一种是重新生成了新的资源文件，旧的依旧存在。
第二种是改了资源文件，设定了新的版本。
```

- 前端安全防范措施

```
https
防止XSS攻击
防止CSRF攻击

```
- 一个成熟的商业的web网站应该有哪些安全保证
``` 
DDos攻击
iframe
opener
CSRF（跨站请求伪造）
XSS（跨站脚本攻击）
ClickJacking（点击劫持）（在HTTP投中加入 X-FRAME-OPTIONS 属性，此属性控制页面是否可被嵌入 iframe 中【DENY：不能被所有网站嵌套或加载；SAMEORIGIN：只能被同域网站嵌套或加载；ALLOW-FROM URL：可以被指定网站嵌套或加载。】）
HSTS（HTTP严格传输安全）
CND劫持

```
- 请解释XSS与CSRF分别是什么，两者有什么联系？如何防御？
``` 
XSS（跨站脚本攻击）
分三种类型：
1.存储型
将脚本注入到服务端数据库中，然后再客户端执行这些脚本。比如：在评论处提交一段脚本代码，前后端如果没做转义，那么久存储到数据库中去了。

2.反射型
通过网络请求来执行脚本，比如：http://baidu.com?q=<script>alert("攻击")</script>

3.文档型
在数据传输过程中劫持网络数据包，修改html文档。比如：wifi路由器劫持，本地恶意软件。

防范措施：
1.对用户输入进行转码或过滤
2.利用CSP
3.利用Cookie的HttpOnly属性，不让JavaScript读取Cookie的值


CSRF（跨站请求伪造）
前提是用户在被攻击网站已经登陆过。

在伪造网页里伪造一个同域名的一个请求，比如：<a herf='http://xxx.com/info?user=aaa&&money=100'>
发送的请求会携带此域名下的Cookie，让服务端以为是正常的请求


防范措施：
1.设定Cookie的SameSite属性
strict模式下完全禁止第三方携带cookie
Lax模式，只允许get请求携带cookie
None模式，也就是默认模式，请求会自动带上Cookie

2.验证来源
根据请求头Origin和Referer字段验证来源

3.Token
服务端生成Token，请求每次都要带上Token，验证是否合法，第三方拿不到这个token
```
- 标签页之间通讯方式
- 首页白屏优化
- 计算首屏加载时间
``` 
window.performance 
```
- 前端存储
- web离线存储

- 单点登录
- 服务端渲染怎么实现window.__inialState__
- service worker和 web worker？
``` 

Web Workers 是 现代浏览器 提供的一个javascript多线程解决方案，我们可以将一些大计算量的代码交由web Worker运行。
// 创建 worker
const myWorker = new Worker('worker.js');

// 向 worker 传递信息
myWorker.postMessage('Hello!');

// 接收从 worker 传递过来的信息
myWorker.onmessage = function(e) {
  console.log(e.data);
}


Service Worker是基于Web Worker的事件驱动的，他们执行的机制都是新开一个线程去处理一些额外的，以前不能直接处理的任务。对于Web Worker，我们可以使用它来进行复杂的计算，因为它并不阻塞浏览器主线程的渲染。而Service Worker，我们可以用它来进行本地缓存或请求转发，相当于一个浏览器端本地的proxy。

```
- 如何做到修改url参数，页面不刷新
- 内存管理（讲了V8的内存管理机制，新生代老生代的算法
- 正常情况下，如果浏览器已经登录了百度账号，再另外打开一个tab页是会自动保持登录状态的，问怎样杜绝这个事情，使得每一次打开都是重新登录，给出实现方案。
- 零点自动刷新
- CI/CD整体流程
