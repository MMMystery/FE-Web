- http状态码
``` 
100 Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
200 OK         正常返回信息
201 Created    请求成功并且服务器创建了新的资源
202 Accepted   服务器已接受请求，但尚未处理
301 Moved Permanently  请求的网页已永久移动到新位置。
302 Found       临时性重定向。
304 Not Modified 自从上次请求后，请求的网页未修改过。

400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
401 Unauthorized 请求未授权，未认证。
403 Forbidden   禁止访问。
404 Not Found   找不到如何与 URI 相匹配的资源。

500 Internal Server Error  最常见的服务器端错误。
502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。传输的数据量过大
504 Gateway Timeout 请求超时


204/206的意思
307 308

服务端如何设置一个302跳转

```
- http协议是传输的是数据流，那么浏览器怎么知道数据传输完了呢，通过什么机制实现的
- http三次握手的作用

- 说一下https的工作原理，里面涉及到的加密算法都有哪些？
```   
HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。
1）使用HTTPS传输数据是安全的，因为数据都是被加密传输的；
2）使用HTTPS需要在服务器端配置密钥对；
3）使用HTTPS需要花钱找专业的权威机构进行CA证书的签发。

用户在浏览器里输入一个https网址，然后连接到server的443端口
采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)
nginx里配置证书的引用，自己之前配置过。
数字证书简称CA，它由权威机构给某网站颁发的一种认可凭证

原理：
https采用了对称加密和非对称加密的结合版本+数字证书。
脑海里过一下https整个过程。



中间人攻击：
SSL劫持攻击和SSL剥离攻击
3.1 SSL劫持攻击
SSL劫持攻击即SSL证书欺骗攻击，攻击者为了获得HTTPS传输的明文数据，需要先将自己接入到客户端和目标网站之间；在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥，这样，中间人就可以得到明文传输带Key1、Key2和Pre-Master-Key，从而窃取客户端和服务端的通信数据；

但是对于客户端来说，如果中间人伪造了证书，在校验证书过程中会提示证书错误，由用户选择继续操作还是返回，由于大多数用户的安全意识不强，会选择继续操作，此时，中间人就可以获取浏览器和服务器之间的通信数据

3.2  SSL剥离攻击
这种攻击方式也需要将攻击者设置为中间人，之后见HTTPS范文替换为HTTP返回给浏览器，而中间人和服务器之间仍然保持HTTPS服务器。由于HTTP是明文传输的，所以中间人可以获取客户端和服务器传输数据

https加密详细过程

```
- https 请求，你通常要注意的是什么 ？
- 介绍SSL和TLS
- 都说要减少 https 的请求，https 为什么慢 ？


- HTTP协议（超文本传输协议）
```
1.0 协议缺陷:
无法复用链接，完成即断开，重新慢启动和 TCP 3次握手
head of line blocking: 线头阻塞，导致请求之间互相影响

1.1 改进:

1.缓存处理
2.带宽优化及网络连接的使用 // HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
3.错误状态码 // 新增了24个错误状态码
4.Host头处理 // 指定对应的虚拟站点
5.长连接(默认 keep-alive)，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟

新增功能:
断点续传
身份认证
状态管理
cache 缓存

Cache-Control
Expires
Last-Modified
Etag

2.0 改进:

1.二进制数据帧和流 // 基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
2.多路复用 // 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求(也就是流)。通过这个技术，可以避免 HTTP1.1版本中的请求a文件时候，b文件只能等待的阻塞问题，极大的提高传输性能。
3.header压缩 // HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
4.服务端推送

http2.0存在什么坑

http3.0？
```
- http/2在实现上只支持https，如何在nginx里配置http2
``` 
配置 Nginx 开启 HTTP/2 特别简单，在 server 配置段中的 listen 后增加 http2 即可。
server {
  listen 443 ssl http2;
  server_name www.hi-linux.com;
  ...
}

开启了 HTTP/2 以后，低版本浏览器也是可正常访问的！如果客户端不支持 HTTP/2 Nginx 会自动向下兼容 HTTP 1.1。
```

- 说一下keep-alive和多路复用
- http2.0有必要去做减少http请求吗
- 服务器端推送原理
- 请求头结构和响应头结构，有哪些字段
```  
请求行、请求头、空行（它的作用是通过一个空行，告诉服务器请求头部到此为止）、请求数据


响应行、响应头、空行和响应体

```

- 讲解一下https对称加密和非对称加密
```
对称加密：
发送方和接收方需要持有同一把密钥，发送消息和接收消息均使用该密钥。相对于非对称加密，对称加密具有更高的加解密速度，但双方都需要事先知道密钥，密钥在传输过程中可能会被窃取，因此安全性没有非对称加密高。
非对称加密：
接收方在发送消息前需要事先生成公钥和私钥，然后将公钥发送给发送方。发送放收到公钥后，将待发送数据用公钥加密，发送给接收方。接收到收到数据后，用私钥解密。
在这个过程中，公钥负责加密，私钥负责解密，数据在传输过程中即使被截获，攻击者由于没有私钥，因此也无法破解。
非对称加密算法的加解密速度低于对称加密算法，但是安全性更高。

```

- dns解析过程

```  
当我们向dns服务器发起解析域名的请求时，dns服务器首先会查询自己的缓存中有没有该域名，如果缓存中存在该域名，则可以直接返回ip地址。如果缓存中没有，服务器则会以递归的方式层层访问。最先从.com根服务器开始，然后baidu.com这样的搜，再www.baidu.com这样的搜索

DNS递归查询和迭代查询知道么




```
- dns的作用
``` 
DNS的作用有哪些？（选项是域名解析、防火墙、负载均衡、控制流量

```
- DNS服务是做什么的，用TCP还是UDP实现
- TCP 的重传机制？

- 三次握手与四次挥手

``` 
三次握手
1）发送端首先发送一个带有SYN（synchronize）标志地数据包给接收方。

2）接收方接收后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了。

3）最后，发送方再回传一个带有ACK标志的数据包，代表我知道了，表示’握手‘结束。

四次挥手

1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

 2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

 3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

 4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手

SYN,ACK分别指什么

```

- TCP重传的机制、浏览器最多能同时发送多少个http请求
- ETag是这个字符串是怎么生成的？

```  

客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。

Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用If-None-Match

Etag 主要为了解决 Last-Modified 无法解决的一些问题。


```

- OSI七层协议, 各个层都在做什么？

```  
7-应用层、6-表示层、5-会话层、4-传输层、3-网络层、2-数据链路层、1-物理层

其中高层（即7、6、5、4层）定义了应用程序的功能，下面3层（即3、2、1层）主要面向通过网络的端到端，点到点的数据流。


HTTP协议对应于应用层，tcp、udp协议对应于传输层，IP协议对应于网络层


```


-fetch和xhr的区别

``` 
Ajax 技术的核心是XMLHttpRequest 对象（简称XHR）。XHR 为向服务器发送请求和解析服务器响应提供了流畅的接口。能够以异步方式从服务器取得更多信息，意味着用户单击后，可以不必刷新页面也能取得新数据。
// 原生XHR
var xhr = new XMLHttpRequest();
xhr.open('GET', url);
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
        console.log(xhr.responseText)   // 从服务器获取数据
    }
}
xhr.send()
readyState的五个状态：

0：初始化，XMLHttpRequest对象还没有完成初始化
1：载入，XMLHttpRequest对象开始发送请求
2：载入完成，XMLHttpRequest对象的请求发送完成
3：解析，XMLHttpRequest对象开始读取服务器的响应
4：完成，XMLHttpRequest对象读取服务器响应结束



fetch号称是ajax的替代品，它的API是基于Promise设计的，旧版本的浏览器不支持Promise，需要使用polyfill es6-promise
fetch(url)
    .then(response => {
        if (response.ok) {
            return response.json();
        }
    })
    .then(data => console.log(data))
    .catch(err => console.log(err))




```
- fetch支持http的哪些方法
- websocket
``` 

WebSocket协议是一种网络协议，它实现了浏览器与服务器的双向通讯的设计，
长连接实时响应数据（股票走势，多媒体聊天，多玩家游戏）。
socket.io升级过程option请求，有时候会轮询。

websocket建立连接的原理

短轮询和长轮询
```

- http的长连接和短连接、长轮询和短轮询
``` 
长连接
长连接是指的TCP连接，而不是HTTP连接

2. 长连接意味着连接会被复用

3. 服务器和客户端都设置 Connection: keep-alive

4. 现在基本用的HTTP1.1协议，HTTP1.1默认长连接

短轮询
浏览器定时向服务器发送请求，看有没有更新的数据。
缺点：
那就是你很浪费服务器和客户端的资源。你不停的请求服务器就很蛋疼了。如果有1000个人停留在某个商品详情页面，那就是说会有1000个客户端不停的去请求服务器获取库存量，这显然是不合理的


长轮询 
页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可以发送。发送完数据之后，浏览器关闭连接，随即又发送一个到服务器的新请求。
优点：
（相对短轮询，在长轮询中，服务器如果检测到库存量没有变化的话，将会把当前请求挂起一段时间（这个时间也叫作超时时间，一般是几十秒）。在这个时间里，服务器会去检测库存量有没有变化，检测到变化就立即返回，否则就一直等到超时为止。）
缺点：
每个服务器所能承载的TCP连接数是有上限的，这种轮询很容易把连接数顶满。

```

- 一个完整url解释

``` 
scheme://host.domain:port/path/filename
各部分解释如下：
scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。
host - 定义域主机（http 的默认主机是 www）
domain - 定义因特网域名，比如 w3school.com.cn
port - 定义主机上的端口号（http 的默认端口号是 80）
path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。
filename - 定义文档/资源的名称

```
- post请求的http请求格式写一下
- TCP和UDP的区别，以及udp的应用
- option请求是为了做什么的？怎么让后端同意接受option
- TCP 的滑动窗口机制
- GET和POST的区别
- 常见Http请求头
- 你觉得http的下一代要解决什么问题？
- 域名能否对应多个ip
- 网络请求header有哪些字段
- 列举常见的content-type
- 域名划分
- 网关切换
- 子网掩码
- ip查找算法
- websocket是如何实现服务器端推送的
- 短连接变成长连接使用了哪些知识点
- 负载均衡
- http  option会被缓存吗；
- url到页面展示过程
```  
dns-prefetch preload prefetch

```


