牛客网，剑指offer和LeetCode，赛码网。.玩转数据结构（慕课网，网上可以找到百度云资源）
leetcode大概150道左右，前端面试基本是easy，偶尔有几个medium的
栈，队列，树，图，数组，单链表，双链表，图

冒泡排序
快速排序
回文字符串
两数之和、k sum
大数相加
二分查找
二叉树前中后遍历
二叉树层次遍历
二叉树深度遍历（分析时间复杂度）
二叉树深度优先遍历(递归、非递归)
二叉树广度优先遍历(递归、非递归)
和为n的二叉树路径
二叉树深度
二叉树是否对称
链表反转
16进制转10进制



- 栈，队列，数组，链表，链表查找的时间复杂度、数组查找的时间复杂度。
- 一道简单的算法题，实现输入一个字符串，返回字符串翻转输出。

```  
1.借用数组的颠倒函数

var str = "abcdef"; 
console.log( str.split("").reverse().join(""))；// 先拆分成数组，颠倒，然后把数组变为字符串

2.借用数组的pop()和push()函数

let str = "abcdef"; 
let strArr = str.split("");
let newArr = [];
while(strArr.length>0){
    newArr.push(strArr.pop())
}
console.log(newArr.join(""));


3.直接倒序取字符元素做拼接

let str="abcdef" 
let newStr = "";

for (let i = 0; i <=str.length; i--) { 
     newStr+=str.charAt(str.length-i-1) // charAt(x)按照下标取出对应字符
}
console.log(newStr)

```
- 在一个无序数组中找到第二大的数
- 统计字符串中单词出现次数
```
function wordCount(str,word){
  var str = str || "";
  var word = word || "";
  var strArr = str.split(" ");
  var count = 0;
  for(var i=0;i<strArr.length;i++){
      if(word===strArr[i]){
          count++
      }
  }
  return count;
}
wordCount("hi how are you i am fine thank you youtube am am","you");

```

```
// 取巧的一种算法，但是每个位置乱序的概率不同
function mixArr(arr){
    return arr.sort(() => {
        return Math.random() - 0.5;
    })
}

// 著名的Fisher–Yates shuffle 洗牌算法
function shuffle(arr){
    let m = arr.length;
    while(m > 1){
        let index = parseInt(Math.random() * m--);
        [arr[index],arr[m]] = [arr[m],arr[index]];
    }
    return arr;
}

```
![图片alt](https://user-gold-cdn.xitu.io/2019/5/30/16b06a9ee7f628db?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 'aa')


- 字符串中找出最长最多重复的子串
```  
TODO


```

- 数组中最大值
```
//方式一（利用延展函数）
Math.max(null,...[1,2,4,32]);
//方式二（排序取第一个）
[1,2,3,5].sort(function(a,b){
    return b - a;
})[0];
```
- 数组中最大差值
``` 


function getMaxProfit(arr){
  var min = arr[0],
      max = arr[0];
  for(var i = 0; i < arr.length; i++){
    if(arr[i] < min) min = arr[i];
    if(arr[i] > max) max = arr[i];
  }
  return max - min;
}
```
- 找出一个数组中最大的2个数之和
- 统计一个字符串出现频率最高的字符

```  

var obj = {}; // 先定义一个空对象,稍后使用.

for (var i = 0; i < str.length; i++) { //   循环字符串中每一项
    var k = str[i]; // 把每一项保存给变量 k (对这一步不理解可先熟悉 for循环机制);

    if (obj[k]) {

        obj[k]++;
    } else {
        obj[k] = 1;
    }
}

console.log(obj); // 输出{d: 1, j: 6, a: 1, o: 2, u: 2, …};

let num = 0;
let value = null;
for (var j in obj) {
    if (obj[j] > num) {
        num = obj[j];            // 这一步是找出出现最多的那个字母, 也就是最大的那个数
        value = j;
    }
}

console.log(value, num); // 输出 "h" 4


```

- 实现一个函数，判断输入是不是回文字符串。

``` 
function Demo(str) {
  let newStr = "";
  for(let i=str.length -1 ;i>=0; i--){
    newStr += str[i];
  }
  return newStr === str;
}

function Demo(str){
    var len = str.length;
    for(var i=0; i<len;i++){
        if(str.charAt(i)!=str.charAt(len-1-i)){
            console.log("不是")
        }else{
            console.log("是")
        }
    } 
}

```
- 合并两个数组
- 数组降维(拍平)

``` 
const flatten = (arr, newArr = []) => {
  arr.forEach(item => Array.isArray(item) ? flatten(item, newArr) : newArr.push(item))
  return newArr;
}

```
- 一道算法题，一个数组中找出所有相同的元素，并且做出分类
- 说出几种数组去重的方式
```  
1.indexOf  提取元素去判断数组里是否有它，没有的都放到新数组里
function uniq(array){
    var temp = []; //一个新的临时数组
    for(var i = 0; i < array.length; i++){
        if(temp.indexOf(array[i]) == -1){
            temp.push(array[i]);
        }
    }
    return temp;
}

2.利用数组的includes方法

function unique5(arr) {
            var newArr = []
            for (var i = 0; i < arr.length; i++) {
                if (!newArr.includes(arr[i])) {
                    newArr.push(arr[i])
                }
            }
            return newArr
        }


3.双层for循环遍历

function uniq(array){
    var temp = [];
    var l = array.length;
    for(var i = 0; i < l; i++) {
        for(var j = i + 1; j < l; j++){
            if (array[i] === array[j]){
                i++;
                j = i;
            }
        }
        temp.push(array[i]);
    }
    return temp;
}

4.利用对象属性

function unique3(arr) {
            var obj={}
            var newArr=[]
            for (let i = 0; i < arr.length; i++) {
                if (!obj[arr[i]]) {
                    obj[arr[i]] = 1
                    newArr.push(arr[i])
                }   
            }
            return newArr
        }

5.利用ES6的set方法

function unique10(arr) {
            //Set数据结构，它类似于数组，其成员的值都是唯一的
            return Array.from(new Set(arr)); // 利用Array.from将Set结构转换成数组
        }


```
- 数组去重复杂度为o(n)的方法
- 数组乱序
``` 
1.sort // 这种方式不好
function shuffle(arr) {
      return arr.sort(() => (Math.random() - 0.5))
  }
  
  console.log(shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))
  
  // =>  [3, 5, 9, 10, 7, 6, 4, 8, 1, 2]


2.洗牌算法(推荐)
// 著名的洗牌算法，原理就是遍历数组元素，将当前元素与随机抽取的一个剩余元素进行交换。
function shuffle(a) {
    for (let i = a.length; i>=0; i--) {
        let j = Math.floor(Math.random() * i);
        [a[i - 1], a[j]] = [a[j], a[i - 1]];
    }
    return a;
}
```


- 如何判断链表是否有环

- 介绍下深度优先遍历和广度优先遍历，如何实现？

```  
深度优先采用的是堆栈的形式, 即先进后出  
分为：
前序遍历：根节点->左子树->右子树
中序遍历：左子树->根节点->右子树
后序遍历：左子树->右子树->根节点



广度优先则采用的是队列的形式, 即先进先出
分为：
层次遍历

TODO

```

- 手写代码实现树的遍历(递归和非递归实现）并计算空间， 时间复杂度

``` 
首先拿深度优先遍历来说：
　　　前序遍历：先遍历根结点，然后左子树，再右子树

　　　中序遍历：先遍历左子树，然后根结点，再右子树

　　　后续遍历：先遍历左子树，然后右子树，再根结点

1.前序遍历
function DLR(tree){
    console.log(tree.value);
    if(tree.left){
        DLR(tree.left);
    }
    if(tree.right){
        DLR(tree.right);
    }
}

2.中序遍历

function LDR(tree){
    if(tree.left){
        LDR(tree.left);
    }
    console.log(tree.value);
    if(tree.right){
        LDR(tree.right);
    }
}

3.后序遍历
 
function LRD(tree){
    if(tree.left){
        LRD(tree.left);
    }
    if(tree.right){
        LRD(tree.right);
    }
    console.log(tree.value);

}


 二叉树的非递归遍历

　　深度优先遍历（主要利用栈的先进后出）

　　广度优先遍历（主要利用队列的先进先出）

//深度优先非递归  ------栈
function DepthFirstSearch(biTree) {
    let stack = [];
    stack.push(biTree);

    while (stack.length != 0) {
        let node = stack.pop();
        console.log(node.data);
        if (node.rChild) {
            stack.push(node.rChild);
        }
        if (node.lChild) {
            stack.push(node.lChild);
        }

    }

}


//广度优先非递归   -----队列
function BreadthFirstSearch(biTree) {
    let queue = [];
    queue.push(biTree);
    while (queue.length != 0) {
        let node = queue.shift();
        console.log(node.data);
        if (node.lChild) {
            queue.push(node.lChild);
        }
        if (node.rChild) {
            queue.push(node.rChild);
        }
    }

}

```
- 层次遍历一棵二叉树(那就是广度优先遍历)
- JS手写二分搜索算法

- 一个有序的数组进行查找操作？（手写） 别说了，二分查找开始吧

``` 
1. 非递归实现
/**
 * 有序的二分查找，返回-1或存在的数组下标。不使用递归实现。
 * @param target
 * @param arr
 * @returns {*}
 */
function binarySearch(target,arr) {
    var start   = 0;
    var end     = arr.length-1;

    while (start<=end){
        var mid = parseInt((start + end) /2);
        if(target==arr[mid]){
            return mid;
        }else if(target>arr[mid]){
            start   = mid+1;
        }else{
            end     = mid-1;
        }
    }
    return -1;
}

2.递归实现

// 递归实现的js代码
function binary_search2(arr, low, high, key) {
	if(low > high) {
		return -1;
	}
	var mid = parseInt((high + low) / 2);
	if(arr[mid] == key) {
		return mid;
	} else if(arr[mid] > key) {
		high =mid -1;
		return binary_search2(arr, low, high, key);
	} else if(arr[mid] < key) {
		low = mid +1;
		return binary_search2(arr, low, high, key);
	}
}

```




- 1、1、2、3、5、8...计算第n个数的值（斐波那契数列）

```  
1.递归
function Demo(n) {
    if(n<=2){
        return 1;
    }
    return Demo(n-1) + Demo(n-2)
}

2.递归优化
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};
  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

3.普通循环

function fibonacci(n) {
    var n1 = 1, n2 = 1, sum;
    for (let i = 2; i < n; i++) {
        sum = n1 + n2
        n1 = n2
        n2 = sum
    }
    return sum
}

4.循环+解构
function Fibonacci3(n){
    if (n===1 || n===2) {
        return 1;
    }
    let ac1 = 1, ac2 = 1;
    for (let i = 2; i < n; i++){
        [ac1, ac2] = [ac2, ac1 + ac2];
    }
    return ac2;
}


```
-   如何从10000个数中找到最大的10个数

```
创建一个最小堆结构，初始值为10000个数的前10个，堆顶为10个数里的最小数。然后遍历剩下的9990个数，如果数字小于堆顶的数，则直接丢弃，否则把堆顶的数删除，将遍历的数插入堆中，堆结构进行自动调整，所以可以保证堆顶的数一定是10个数里最小的。遍历完毕后，堆里的10个数就是这10000个数里面最大的10个。

```




- 不借助第三者交换 a，b两个值

```

/* 方法一 */
a = a + b;
b = a - b;
a = a - b;

/* 方法二 */
a = a - b;
b = a + b;
a = b - a;

/* 方法三 */
a = {a:b,b:a};
b = a.b;
a = a.a;

/* 方法四 */
a = [a,b];
b = a[0];
a = a[1];

/* 方法五 */
[a,b] = [b,a];

```

- 判断一个数是否是整数
```
      function isIntefer(x){
        return x%1===0; //返回布尔
    }

```


- 写一下希尔排序算法，注意空间和时间复杂度。
- 手写一下快速排序算法。

```  
var quickSort = function(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  var pivotIndex = Math.floor(arr.length / 2);
  var pivot = arr.splice(pivotIndex, 1)[0];
  var left = [];
  var right = [];

  for (var i = 0; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat([pivot], quickSort(right));
};


```
- 用数组的reduce方法实现数组拍平算法
- 要是数组长度非常大会出现什么情况
- 找出两个有序数组中的重复项，分析时间和空间复杂度
- 找出缺失的最小正整数 leetcode原题
- 从一千万行ip4地址中匹配一条ip4v地址, 思路
- 一句话, 将其反转, 但是每个单词不变
- 用链表实现一个队列(手撕)
- 找出最长连续递增序列(手撕)
- 如果找出不连续的最长递增(思路)
- JS实现单向链表
- 订阅发布者模式, 实现on, off, trigger, 写完了然后让写一个once
- [0,0,1,1,1,2,3,4,5]，不借用辅助空间找到不重复项[2，3，4，5]
- 算法：数组中最大连续子序和
- 写出双向链表
- 手写链表反转
- 合并两个有序链表
- 两行代码实现数组各元素+1；
- 链表有哪几种。单链表和双链表的区别
- 判断两个二叉树是否相等
- 二叉树节点交换
- 链表求和二叉树层序遍历
- 随机排座位算法，要有连坐功能
- 判断一个单向链表是否为循环链表
- 1000个数找到2个数和为100的所有数
- 写代码：写一下归并排序合并两个有序数组的过程
- 写代码：求多个数组的交集（用归并的思想进行优化）
- 输入一个数字n，输出从1到n的所有排列，比如输入3，输出123、132、213、231、312、321
- 有两个有序数组M和N，怎么判断N是否为M的子集？
- 输入一棵二叉树，判断该二叉树是否是平衡二叉树。
- sort()是内部使用了什么算法 时间复杂度是多少 indexOf()的时间复杂度是多少
在线写代码，给定一个二叉树，求根节点到叶子节点的路径上所有节点值之和（DFS，先序遍历，递归）
在线写代码，给定两个有序数组，合并为一个有序数组。不许使用 js 的 concat 和 sort 方法（两个指针）
- 如何在二叉树中插入结点
- 用数组表示二叉树
- 01背包问题
- 找出01序列最长的连续1的长度
- 楼梯问题:每次只能走1 2步, 有多少种走法
- 数字->字符串对应, leetcode原题, 1:a, 2:b, 3:c.......给一串数字变回字符串
- 输入任意数量的数组，输出它们的笛卡尔积